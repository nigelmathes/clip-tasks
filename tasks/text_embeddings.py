# Generate embedded text labels
from typing import List, Union
from pathlib import Path

import clip
import numpy as np
import torch

from tqdm import tqdm

from utils import get_model_and_preprocess, get_device


def prompt_engineered_text_embeddings(
    text_inputs: List[str], prompt_templates: List[str]
) -> torch.Tensor:
    """
    Function to perform prompt engineering and create text embeddings

    Args:
        text_inputs: Individual text inputs, such as "a cat"
        prompt_templates: Optional prepended descriptions, such as "a picture of {}"
                          NOTE: Requires "{}" to format-fill with text inputs

    Returns:
        Tensor of embedded weights
    """
    # Get torch device, CLIP model, preprocessing pipeline
    device = get_device()
    model, preprocess = get_model_and_preprocess()

    with torch.no_grad():
        text_embeddings = []
        for text_input in tqdm(text_inputs):
            # Create text prompts, combining all prompt_templates with all text_inputs
            text_prompts = [
                template.format(text_input) for template in prompt_templates
            ]
            text_prompts = clip.tokenize(text_prompts).to(device)

            # Create embeddings using CLIP model and its encoder
            encoded_text = model.encode_text(text_prompts)
            encoded_text /= encoded_text.norm(dim=-1, keepdim=True)
            text_embedding = encoded_text.mean(dim=0)
            text_embedding /= text_embedding.norm()

            # Add a given text's embeddings to the list of weights
            text_embeddings.append(text_embedding)

        # Reshape weights along axis=1
        text_embeddings = torch.stack(text_embeddings, dim=1).to(device)

    return text_embeddings


def get_text_embeddings(
    text_inputs: List[str], prompt_templates: List[str]
) -> torch.Tensor:
    """
    Load or compute a Tensor of text embeddings

    Args:
        text_inputs: Individual text inputs, such as "a cat"
        prompt_templates: Optional prepended descriptions, such as "a picture of {}"
                          NOTE: Requires "{}" to format-fill with text inputs

    Returns:
        Tensor of embedded weights
    """
    try:
        text_embeddings = load_text_embeddings()
    except FileNotFoundError:
        text_embeddings = prompt_engineered_text_embeddings(
            text_inputs=text_inputs, prompt_templates=prompt_templates
        )
        save_text_embeddings(text_embeddings=text_embeddings)

    return text_embeddings


def save_text_embeddings(
    text_embeddings: torch.Tensor,
    filename: Union[str, Path] = Path("outputs/text_embeddings.npy"),
) -> Union[str, Path]:
    """
    Save text embeddings generated by compute_text_embeddings(), defaulting to
    ./outputs/text_embeddings.npy

    Args:
        text_embeddings: A PyTorch tensor of embedded weights for text/prompt
                         combinations
        filename: Name of file to write

    Returns:
        The name of the file the embeddings have been saved as
    """
    numpy_embeddings = text_embeddings.cpu().numpy()
    np.save(filename, numpy_embeddings)

    return filename


def load_text_embeddings(
    filename: Union[str, Path] = Path("outputs/text_embeddings.npy")
) -> torch.Tensor:
    """
    Load text embeddings from a .npy save file, defaulted to reading the file at
    ./outputs/text_embeddings.npy

    Args:
        filename: Name of the file containing text embeddings

    Returns:

    """
    loaded_embeddings = np.load(filename)
    processed_embeddings = torch.from_numpy(loaded_embeddings).to(get_device())

    return processed_embeddings
